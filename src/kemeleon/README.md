
# Ciphertext Encoding

## Randomness Management

The Kemeleon algorithm for encoding ML-KEM ciphertexts relies on randomness in two places - steps 3 and 8 in the figure
below. However if we use a good source of randomness this leads to the following undesirable properties.

1. For a single ciphertext, each call encode results in a different encoded value.

2. For a single ciphertext, determining whether we reject or accept the encoding is dependent on the values sampled from
the source of randomness. So subsequent calls to encode may either reject or accept with no consistency.

![Ciphertext Encoding steps requiring randomness](../../doc/Kemeleon.EncodeCiphertext.png)

In order to prevent these properties we require a secure deterministic source of random bytes. We construct our
deterministic source of randomness using an HKDF over the FIPS representation of the ciphertext and the associated
shared secret. This expanded secret, unique to the created handshake, creates a deterministic set of bytes that can only
be generated by the participating members of the ML-KEM handshake. Our encoding now 1) is encoded to the same value
every time it is encoded and 2) will _always_ be accepted or rejected on subsequent calls to encode.

### How many random bytes are required?

In order to answer this we have to give slightly more detail about how the algorithms use random values.

In steps 2-4 we iterate over the $K \times N$ values in the `U` element of the ciphertext.

In steps 7-8 we iterate over the `N` values in the `V` element of the ciphertext and reject conditionally if both
the $i^{th}$ value is equal to 0 AND our we sample values between 0 and `Q` and the value is below $2^{d_v}$.
Given that 2 bytes is enough for a value in $[0,Q]$, we need $N \times 2$ bytes of randomness.
An example implementation looks like:

```rust
fn rejection_sample<R: CryptoRng + RngCore>(c2: &[u8], rng: &mut R, dv: usize) -> bool {
    let lim = 2_u16.pow(dv as u32);
    let mut b = [0u8; 2];
    for val in c2 {
        rng.fill_bytes(&mut b);
        let y = u16::from_be_bytes(b);
        if *val == 0 && y % 3329 < lim {
            return false;
        }
    }
    true
}
```


In total we require

$$
K \times N \times 2 + N \times 2 = 2N(K + 1) \\[10pt]
512 => (N:256, K:2) => 1536 \text{ B}\\
768 => (N:256, K:3) => 2048 \text{ B} \\
1024 => (N:256, K:4) => 2560 \text{ B}
$$
